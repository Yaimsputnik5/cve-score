import unittest
import numpy as np

from encoders import _BoWEncoder
from encoders import DenseEncoder
from encoders import TfEmbeddingEncoder
from encoders import NumericEncoder
from encoders import SparseEncoder
from encoders import trim_vocabulary


class MethodsTest(unittest.TestCase):

    def test_trim_vocabulary(self):

        vocabulary = {
            'foo': 2, 'bar': 1, 'baz': 1
        }
        expected = ['foo', 'baz', 'bar']

        self.assertEqual(expected, trim_vocabulary(vocabulary))


class BoWEncoderTest(unittest.TestCase):

    def test_dictionary_initializer(self):

        vocabulary = {
            'foo': 0.3, 'bar': 0.1, 'baz': 0.2
        }
        # [bar, baz, foo] => [2, 1, 0]
        data = ['baz', 'qux', 'foo']
        expected = [1, 0]

        encoder = _BoWEncoder(vocabulary)
        self.assertEqual(expected, encoder(data))

    def test_encoder_correctness(self):

        vocabulary = {
            'foo': 0.3, 'bar': 0.1, 'baz': 0.2
        }
        # [bar, baz, foo] => [2, 1, 0]
        vocabulary_max_size = 2
        data = ['baz', 'bar']
        expected = [1]

        encoder = _BoWEncoder(
            vocabulary, vocabulary_max_size=vocabulary_max_size)
        self.assertEqual(expected, encoder(data))


class DenseEncoderTest(unittest.TestCase):

    def test_delegated_initializer(self):
        # BoWEncoderTest.test_dictionary_initializer

        vocabulary = {
            'foo': 3, 'bar': 1, 'baz': 2
        }
        data = ['baz', 'qux', 'foo']
        expected = [1, 0]

        encoder = DenseEncoder(vocabulary)
        self.assertEqual(expected, encoder(data))

    def test_transform(self):

        vocabulary = {
            'foo': 3, 'bar': 1, 'baz': 2
        }
        encoder = DenseEncoder(vocabulary)

        data = [
            [2, 1], [0, 2],
        ]
        onehot = [
            [0, 1, 1], [1, 0, 1],
        ]

        actual = encoder.transform(data)
        expected = np.array(onehot, dtype=np.float32)
        self.assertTrue(np.allclose(expected, actual))


class SparseEncoderTest(unittest.TestCase):

    def test_transform(self):

        vocabulary = {
            'foo': 3, 'bar': 1, 'baz': 2
        }
        encoder = SparseEncoder(vocabulary)

        data = [
            [2, 1], [0, 2],
        ]
        onehot = [
            [0, 1, 1], [1, 0, 1],
        ]

        actual = encoder.transform(data).toarray()
        expected = np.array(onehot, dtype=np.float32)
        self.assertTrue(np.allclose(expected, actual))


class NumericeEncoderTest(unittest.TestCase):

    def test_transform(self):

        data = [[1], [3], [2]]
        expected_shape = (3, 1)

        encoder = NumericEncoder()
        actual = encoder.transform(data)
        self.assertEqual(expected_shape, actual.shape)


class TfEmbeddingEncoderTest(unittest.TestCase):

    def test_encoder_correctness(self):

        vocabulary = {
            'foo': 3, 'bar': 1, 'baz': 2
        }
        # [bar, baz, foo] => [3, 2, 1]
        input_length = 2
        encoder = TfEmbeddingEncoder(vocabulary, input_length)

        data = ['baz', 'bar']
        expected = [2, 3]

        self.assertEqual(expected, encoder(data))

    def test_transform(self):

        vocabulary = {
            'foo': 3, 'bar': 1, 'baz': 2
        }
        # [bar, baz, foo] => [3, 2, 1]
        input_length = 2
        encoder = TfEmbeddingEncoder(vocabulary, input_length)

        data = [
            [3, 2],
            [2],
            [3, 2, 1],
        ]
        embedded = [
            [3, 2],
            [2, 0],
            [3, 2],
        ]

        actual = encoder.transform(data)
        expected = np.array(embedded, dtype=np.int32)
        self.assertTrue(np.array_equal(expected, actual))
