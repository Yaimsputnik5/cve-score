import unittest
import numpy as np

from encoders import _BoWEncoder
from encoders import DenseEncoder
from encoders import NumericEncoder
from encoders import SparseEncoder


class BoWEncoderTest(unittest.TestCase):

    def test_dictionary_initializer(self):

        vocabulary = {
            'foo': 0.3, 'bar': 0.1, 'baz': 0.2
        }
        # [bar, baz, foo] => [2, 1, 0]
        data = ['baz', 'qux', 'foo']
        expected = [1, 0]

        encoder = _BoWEncoder(vocabulary)
        self.assertEqual(expected, encoder(data))

    def test_dictionary_initializer(self):

        vocabulary = {
            'foo': 0.3, 'bar': 0.1, 'baz': 0.2
        }
        # [bar, baz, foo] => [2, 1, 0]
        vocabulary_max_size = 2
        data = ['baz', 'bar']
        expected = [1]

        encoder = _BoWEncoder(
            vocabulary, vocabulary_max_size=vocabulary_max_size)
        self.assertEqual(expected, encoder(data))


class DenseEncoderTest(unittest.TestCase):

    def test_properties(self):

        vocabulary = {
            'foo': 0.3, 'bar': 0.1, 'baz': 0.2
        }
        expected = {
            'encoder': 'dense',
            'dimension': 3
        }

        encoder = DenseEncoder(vocabulary)
        self.assertEqual(expected, encoder.PROPERTIES)

    def test_delegated_initializer(self):
        # BoWEncoderTest.test_dictionary_initializer

        vocabulary = {
            'foo': 0.3, 'bar': 0.1, 'baz': 0.2
        }
        data = ['baz', 'qux', 'foo']
        expected = [1, 0]

        encoder = DenseEncoder(vocabulary)
        self.assertEqual(expected, encoder(data))

    def test_transform(self):

        vocabulary = {
            'foo': 0.3, 'bar': 0.1, 'baz': 0.2
        }
        encoder = DenseEncoder(vocabulary)

        data = [
            [2, 1], [0, 2],
        ]
        onehot = [
            [0, 1, 1], [1, 0, 1],
        ]

        actual = encoder.transform(data)
        expected = np.array(onehot, dtype=np.float32)
        self.assertTrue(np.allclose(expected, actual))


class SparseEncoderTest(unittest.TestCase):

    def test_properties(self):

        vocabulary = {
            'foo': 0.3, 'bar': 0.1, 'baz': 0.2
        }
        expected = {
            'encoder': 'sparse',
            'dimension': 3
        }

        encoder = SparseEncoder(vocabulary)
        self.assertEqual(expected, encoder.PROPERTIES)

    def test_transform(self):

        vocabulary = {
            'foo': 0.3, 'bar': 0.1, 'baz': 0.2
        }
        encoder = SparseEncoder(vocabulary)

        data = [
            [2, 1], [0, 2],
        ]
        onehot = [
            [0, 1, 1], [1, 0, 1],
        ]

        actual = encoder.transform(data).toarray()
        expected = np.array(onehot, dtype=np.float32)
        self.assertTrue(np.allclose(expected, actual))


class NumericeEncoderTest(unittest.TestCase):

    def test_properties(self):

        expected = {
            'encoder': 'numeric',
            'dtype': 'float32'
        }
        encoder = NumericEncoder('float32')
        self.assertEqual(expected, encoder.PROPERTIES)

    def test_transform(self):

        data = [[1], [3], [2]]
        expected_shape = (3, 1)

        encoder = NumericEncoder()
        actual = encoder.transform(data)
        self.assertEqual(expected_shape, actual.shape)
