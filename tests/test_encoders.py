import unittest
import numpy as np

from encoders import _BoWEncoder
from encoders import DenseEncoder
from encoders import NumericEncoder
from encoders import SifEmbeddingEncoder
from encoders import SparseEncoder
from encoders import TfEmbeddingEncoder
from encoders import trim_vocabulary


class MethodsTest(unittest.TestCase):

    def test_trim_vocabulary_ordering(self):

        vocabulary = {
            'foo': 2, 'bar': 1, 'baz': 1
        }
        expected = ['foo', 'baz', 'bar']

        self.assertEqual(expected, trim_vocabulary(vocabulary))

    def test_trim_vocabulary_max_size(self):

        vocabulary = {
            'foo': 2, 'bar': 1, 'baz': 1
        }
        max_size = 2
        expected = ['foo', 'baz']

        actual = trim_vocabulary(vocabulary, vocabulary_max_size=max_size)
        self.assertEqual(expected, actual)

    def test_trim_vocabulary_min_freq(self):

        vocabulary = {
            'foo': 2, 'bar': 1, 'baz': 1
        }
        min_freq = 2
        expected = ['foo']

        actual = trim_vocabulary(vocabulary, vocabulary_min_freq=min_freq)
        self.assertEqual(expected, actual)


class NumericEncoderTest(unittest.TestCase):

    def test_transform(self):

        data = [[1], [3], [2]]
        expected_shape = (3, 1)

        encoder = NumericEncoder()
        actual = encoder.transform(data)
        self.assertEqual(expected_shape, actual.shape)


class BoWEncoderTest(unittest.TestCase):

    def test_dictionary_initializer(self):

        vocabulary = {
            'foo': 3, 'bar': 1, 'baz': 2
        }
        # [bar, baz, foo] => [2, 1, 0]
        data = ['baz', 'qux', 'foo']
        expected = [1, 0]

        encoder = _BoWEncoder(vocabulary)
        self.assertEqual(expected, encoder(data))

    def test_encoder_with_max_size(self):

        vocabulary = {
            'foo': 3, 'bar': 1, 'baz': 2
        }
        # [baz, foo] => [1, 0]
        vocabulary_max_size = 2
        data = ['baz', 'bar']
        expected = [1]

        encoder = _BoWEncoder(
            vocabulary, vocabulary_max_size=vocabulary_max_size)
        self.assertEqual(expected, encoder(data))

    def test_encoder_with_min_freq(self):

        vocabulary = {
            'foo': 3, 'bar': 1, 'baz': 2
        }
        # [baz, foo] => [1, 0]
        vocabulary_min_freq = 2
        data = ['baz', 'bar']
        expected = [1]

        encoder = _BoWEncoder(
            vocabulary, vocabulary_min_freq=vocabulary_min_freq)
        self.assertEqual(expected, encoder(data))


class DenseEncoderTest(unittest.TestCase):

    def test_delegated_initializer(self):
        # BoWEncoderTest.test_dictionary_initializer

        vocabulary = {
            'foo': 3, 'bar': 1, 'baz': 2
        }
        data = ['baz', 'qux', 'foo']
        expected = [1, 0]

        encoder = DenseEncoder(vocabulary)
        self.assertEqual(expected, encoder(data))

    def test_transform(self):

        vocabulary = {
            'foo': 3, 'bar': 1, 'baz': 2
        }
        encoder = DenseEncoder(vocabulary)

        data = [
            [2, 1], [0, 2],
        ]
        onehot = [
            [0, 1, 1], [1, 0, 1],
        ]

        actual = encoder.transform(data)
        expected = np.array(onehot, dtype=np.float32)
        self.assertTrue(np.allclose(expected, actual))


class SparseEncoderTest(unittest.TestCase):

    def test_transform(self):

        vocabulary = {
            'foo': 3, 'bar': 1, 'baz': 2
        }
        encoder = SparseEncoder(vocabulary)

        data = [
            [2, 1], [0, 2],
        ]
        onehot = [
            [0, 1, 1], [1, 0, 1],
        ]

        actual = encoder.transform(data).toarray()
        expected = np.array(onehot, dtype=np.float32)
        self.assertTrue(np.allclose(expected, actual))


class TfEmbeddingEncoderTest(unittest.TestCase):

    def test_encoder_correctness(self):

        vocabulary = {
            'foo': 3, 'bar': 1, 'baz': 2
        }
        # [bar, baz, foo] => [3, 2, 1]
        input_length = 2
        encoder = TfEmbeddingEncoder(vocabulary, input_length)

        data = ['baz', 'bar']
        expected = [2, 3]

        self.assertEqual(expected, encoder(data))

    def test_transform(self):

        vocabulary = {
            'foo': 3, 'bar': 1, 'baz': 2
        }
        # [bar, baz, foo] => [3, 2, 1]
        input_length = 2
        encoder = TfEmbeddingEncoder(vocabulary, input_length)

        data = [
            [3, 2],
            [2],
            [3, 2, 1],
        ]
        embedded = [
            [3, 2],
            [2, 0],
            [3, 2],
        ]

        actual = encoder.transform(data)
        expected = np.array(embedded, dtype=np.int32)
        self.assertTrue(np.array_equal(expected, actual))


class SifEmbeddingEncoderTest(unittest.TestCase):

    ALPHA = 1
    EMBEDDING = {
        'foo': np.array([0.1, -0.1], dtype=np.float32),
        'bar': np.array([0.0, 0.2], dtype=np.float32),
        'baz': np.array([0.0, 0.25], dtype=np.float32),
    }

    def test_initializer_projects_to_embedding(self):

        vocabulary = {
            'foo': 4, 'bar': 3, 'qux': 2, 'baz': 1
        }
        # index => {foo: 0, bar: 1, baz: 2}
        data = ['baz', 'qux', 'foo', 'bar']
        expected = [2, 0, 1]

        encoder = SifEmbeddingEncoder(vocabulary, self.EMBEDDING, self.ALPHA)
        self.assertEqual(expected, encoder(data))

    def test_transformer_dimensions(self):

        vocabulary = {
            'foo': 4, 'bar': 3, 'qux': 2,
        }
        data = [
            ['bar', 'foo'],
            ['foo', 'bar', 'foo', 'baz'],
            ['qux', 'foo'],
        ]
        expected_shape = (3, 2)
        encoder = SifEmbeddingEncoder(vocabulary, self.EMBEDDING, self.ALPHA)
        transformed = encoder.transform(map(encoder, data))
        self.assertEqual(expected_shape, transformed.shape)
