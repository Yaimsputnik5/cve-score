#!/usr/bin/env python3

import click
import json
import logging
from collections import defaultdict

from common import load_json, deserialize, serialize
import encoders
import settings

LOGGER = logging.getLogger('cve-score')

META_KEY = 'META'

ENCODERS = {
    'dense': encoders.DenseEncoder,
    'sparse': encoders.SparseEncoder,
    'numeric': encoders.NumericEncoder,
    'sif_emmbedding': encoders.SifEmbeddingEncoder,
    'tf_embedding': encoders.TfEmbeddingEncoder,
}


def get_encoder(config, vocabulary, embedding=None):
    '''Factory method to instantiate a class in the `encoders` module,
    tied to a particular key.

    Arguments:
        config: [dict] specifying the "key," "encoder" type, and additional
            constructor arguments.
        vocabulary: [dict] mapping keys to token-frequency mappings.

    Returns a pair (key, encoder) on success, consisting of a string and a
    lambda function. Returns `None` on failure.
    '''
    encoder_name = config.get('encoder')
    if encoder_name is None:
        return None
    if encoder_name not in ENCODERS:
        LOGGER.warning('unrecognized encoder: %s', encoder_name)
        return None
    key = config['key']
    constructor = ENCODERS[encoder_name]
    ctor_args = dict(vocabulary=vocabulary.get(key),
        embedding=embedding,
        **config)
    try:
        return (key, constructor(**ctor_args))
    except (ValueError, TypeError) as ex:
        LOGGER.warning('failure to instantiate "%s": %s', encoder_name, ex)
        return None


def encode(encoders, records):
    '''Converts a stream of JSON records into a dictionary of numpy arrays.

    Arguments:
        encoders: list of (key, encoder) pairs, where the right hand value
            is an instance from the `encoders` module.
        records: file of line-separated JSON records.

    Returns a dictionary mapping "keys" from encoders list to numpy objects.
    '''
    indices = defaultdict(list)
    for record in map(json.loads, records):
        for (key, encoder) in encoders:
            indices[key].append(encoder(record[key]))

    return {
        key: encoder.transform(indices[key])
        for (key, encoder) in encoders
    }


@click.command()
@click.argument('config')
@click.argument('infile')
@click.argument('outfile')
@click.option('--vocabulary',
    help='JSON dictionary emitted by preprocess script')
@click.option('--embedding',
    help='pickled dictionary of 1D NumPy tensors')
def main(config, infile, outfile, vocabulary, embedding):
    '''Transforms a file of preprocessed JSON records into a dictionary of
    NumPy tensords.

    CONFIG is a JSON array of config objects, one for each "target" key.
    INFILE is the file of preprocessed data in line-separated JSON format.
    OUTFILE is a pickled dictionary whose keys correspond to target keys
    in the CONFIG, and whose values are NumPy tensors.
    '''
    config = load_json(config)
    vocabulary = load_json(vocabulary) if vocabulary else {}
    embedding = deserialize(embedding) if embedding else None
    encoders = list(filter(None,
        [get_encoder(item, vocabulary, embedding) for item in config]))

    with open(infile) as fh:
        LOGGER.info('reading %s', infile)
        data = encode(encoders, fh)

    for key, tensor in data.items():
        LOGGER.info('key: "%s" shape: %s', key, tensor.shape)

    serialize(outfile, data)


if __name__ == '__main__':
    settings.configure_logging()
    main()
