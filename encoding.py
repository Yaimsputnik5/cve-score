#!/usr/bin/env python3

import argparse
import json
import logging
import sys

import tensorflow as tf
from settings import configure_logging

LOGGER = logging.getLogger('cve-score')


def _bow_transform(tokens, key, vocabulary, **kwargs):
    '''Creates bag-of-words-encoding from a list of tokens.

    Arguments:
        tokens:     [list] tokens to be encoded.
        key:        [str] feature name in output protobuf.
        vocabulary: [list] defines "columns" of encoding.

    Returns: `(<key>, tf.train.Feature)` pair, where the first component
        is from the argument list, and the send is a protobuf.
    '''
    tokens = set(tokens)
    bow = [(1.0 if word in tokens else 0.0) for word in vocabulary]
    return (
        key,
        tf.train.Feature(float_list=tf.train.FloatList(value=bow))
    )


def _label_transform(value):
    return (
        'label',
        tf.train.Feature(int64_list=tf.train.Int64List(value=[value]))
    )


def _weight_transform(value):
    return (
        'weight',
        tf.train.Feature(float_list=tf.train.FloatList(value=[value or 1.0]))
    )


def _get_transform(spec):
    '''Converts a spec into a transformation. The transformation is a
    function with the signature `<value> => (<key>, <Feature protobuf>)`.
    '''
    if 'vocabulary' in spec:
        return lambda tokens: _bow_transform(tokens, **spec)
    if spec.get('isLabel', False):
        return _label_transform
    if spec.get('isWeight', False):
        return _weight_transform

    raise ValueError('invalid specification %s' % spec)


def get_encoder(features):
    '''Converts a config object into a encoder. The encoder is a function
    with the signature `<dict> => <Example>`, where the input is a deserialized
    JSON record, and the output is a `tf.train.Example` protobuf.
    '''
    transforms =[
        (spec['key'], _get_transform(spec)) for spec in features
    ]

    def encoder(record):
        pairs = [xform(record.get(key)) for (key, xform) in transforms]
        return tf.train.Example(
            features=tf.train.Features(feature=dict(pairs)))

    return encoder


def _parse_spec(spec):
    if 'vocabulary' in spec:
        return (spec['key'], [len(spec['vocabulary'])], tf.float32)
    if spec.get('isLabel', False):
        return ('label', [1], tf.int64)
    if spec.get('isWeight', False):
        return ('weight', [1], tf.float32)

    raise ValueError('invalid specification %s' % spec)


def get_parser(features):
    '''Converts a config object into protobuf parser. The parser is a function
    with signature `<Example> => (<dict>, <tensor>)`, where the input is a
    `tf.Example` protobuf, and the output is a pair of `tf.Tensors`. (The
    first component associates feature names to tensors.)
    '''
    decoders = {
        name: tf.FixedLenFeature(shape, dtype)
        for (name, shape, dtype) in map(_parse_spec, features)
    }
    LOGGER.debug('decoders => %s', decoders)

    def parser(serialized):
        example = tf.parse_single_example(serialized, decoders)
        label = example.pop('label')
        return (example, label)

    return parser


def get_feature_columns(features):
    return [
        tf.feature_column.numeric_column(key, shape, dtype=dtype)
        for (key, shape, dtype) in map(_parse_spec, features)
        if key not in {'label', 'weight'}
    ]


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('config', help='JSON file for encodings')
    parser.add_argument('outfile', help='target file of tfrecords')
    parser.add_argument('--infile',
        type=argparse.FileType('r'),
        default=sys.stdin,
        help='JSON records, one per line [stdin]')
    args = parser.parse_args()
    configure_logging()

    with open(args.config) as fh:
        encoder = get_encoder(json.load(fh))

    with tf.python_io.TFRecordWriter(args.outfile) as writer:
        counter = 0
        for example in map(encoder, map(json.loads, args.infile)):
            writer.write(example.SerializeToString())
            counter += 1

    LOGGER.info('wrote %d records to %s', counter, args.outfile)
