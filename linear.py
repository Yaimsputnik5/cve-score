#!/usr/bin/env python3

import argparse
import json
import logging

import numpy as np
from scipy import sparse
from sklearn.linear_model import SGDClassifier
from sklearn.metrics import roc_auc_score

from common import serialize, deserialize
import settings


LOGGER = logging.getLogger('cve-score')

CLF_DEFAULTS = {
    'loss': 'log',
    'penalty': 'elasticnet',
    'class_weight': 'balanced',
    'alpha': 1e-4,
    'l1_ratio': 0.0,
    'tol': 1e-4,
}

_PARSER = argparse.ArgumentParser()
_PARSER.add_argument('command', help='train|eval')
_PARSER.add_argument('dataset', help='serialized dict of numpy arrays')
_PARSER.add_argument('estimator', help='serialized sklearn estimator')
_PARSER.add_argument('--feature-keys', nargs='*',
    help='feature key in dataset')
_PARSER.add_argument('--label-key', help='label key in dataset')
_PARSER.add_argument('--alpha', type=float, default=1e-4,
    help='classifier L2 penalty term')
_PARSER.add_argument('--l1-ratio', type=float, default=0,
    help='classifier Elastic Net mixing parameter')


def reformat(data, feature_keys, label_key=None):
    '''Massages a dictionary of numpy arrays into a pair consumable by
    estimators in the sklearn API.

    Arguments:
        data: dictionary associating names to NumPy/SciPy objects.
        feature_keys: list selecting values in `data` to combine into the
            design matrix.
        label_key: [str|None] selects the array in `data` for the labels.

    Returns a pair (X, y), where y is `None` if label_key is not supplied.
    '''
    feature_keys = [key for key in feature_keys if key in data]
    LOGGER.info('using features: %s', json.dumps(feature_keys))

    labels = data.get(label_key)
    features = [data[key] for key in feature_keys]
    if isinstance(features[0], np.ndarray):
        return np.hstack(features), labels
    elif isinstance(features[0], sparse.spmatrix):
        return sparse.hstack(features), labels


def train(dataset, estimator, feature_keys, label_key, **kwargs):
    '''Implements the "train" command.'''
    data = deserialize(dataset)
    features, labels = reformat(data, feature_keys, label_key)
    params = {
        key: kwargs.get(key, default)
        for (key, default) in CLF_DEFAULTS.items()
    }
    LOGGER.info('estimator params => %s', json.dumps(params))
    clf = SGDClassifier(**params)
    clf.fit(features, labels)
    serialize(estimator, clf)


def eval(dataset, estimator, feature_keys, label_key, **kwargs):
    '''Implements the "eval" command.'''
    data = deserialize(dataset)
    features, labels = reformat(data, feature_keys, label_key)
    clf = deserialize(estimator)
    class_probs = clf.predict_proba(features)
    if label_key is not None:
        metrics = dict(AUC=roc_auc_score(labels, class_probs[:, 1]))
        LOGGER.info('metrics => %s', json.dumps(metrics))


if __name__ == '__main__':
    args = _PARSER.parse_args()
    settings.configure_logging()

    if args.command == 'train':
        train(**vars(args))
    elif args.command == 'eval':
        eval(**vars(args))
    else:
        print('invalid command: %s' % args.command)
