import logging
import numpy as np
from scipy import sparse
from sklearn import metrics
from collections import namedtuple

# basic structure marshalling numpy data.
Data = namedtuple('Data', ['features', 'labels'])

def load_data(config):
    '''Loads numpy data from files. The `config` argument must be a dictionary
    with the following keys:

        "features"  => filename of NPZ serialized sparse matrix
        "labels"    => filename of numpy serialized array
    '''
    logging.info('loading %s', config['labels'])
    labels = np.load(config['labels'])
    logging.info('loading %s', config['features'])
    features = sparse.load_npz(config['features'])
    logging.info('features.shape => %s', features.shape)

    if features.shape[0] != labels.shape[0]:
        raise ValueError('size mismatch between features, labels')

    return Data(features, labels)


SCORE_METHODS = [
    ('precision', metrics.precision_score),
    ('recall', metrics.recall_score),
    ('accuracy', metrics.accuracy_score),
]

def scores(y_true, y_pred):
    '''
    Arguments:
        y_true:  [array, shape=(n_samples,)]  Ground truth values in {0, 1}.
        y_pred:  [array, shape=(n_samples,)]  Predicted values in {0, 1}.

    Returns [dict].
    '''
    return {name: func(y_true, y_pred) for (name, func) in SCORE_METHODS}

def probabilities(y_true, y_probs, classes):
    '''
    Arguments:
        y_true:  [array, shape=(n_samples,)]  Ground truth values in {0, 1}.
        y_probs: [array, shape=(n_samples,)]  Likelihood values in [0, 1].
        classes: [array, shape=(n_classes,)]  Class labels for estimator.

    Returns [list].
    '''
    positve_index = np.argmax(classes)
    positve_probs = y_probs[:, positve_index]
    return [
        dict(label=label, prob=prob) for (label, prob) in zip(y_true, positve_probs)
    ]
