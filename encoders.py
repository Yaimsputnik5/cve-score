import numpy as np
from scipy import sparse


def _trim_vocabulary(vocabulary, vocabulary_max_size=None):
    '''Extracts a vocabulary constrained to a target size.

    Arguments:
        vocabulary: [dict] mapping tokens to frequencies.
        vocabulary_max_size: [int] target size of return value. If `None`
            the full vocabulary is used, and likewise if it exceeds the
            size of the input.

    Returns a _list_ of target size.
    '''
    size = vocabulary_max_size or len(vocabulary)
    if isinstance(vocabulary, dict):
        sorted_ = sorted(
            vocabulary.items(), key=lambda pair: pair[1], reverse=True)
        return [token for (token, _) in sorted_[:size]]
    raise ValueError('"vocabulary" must be a dict.')


class _BoWEncoder(object):
    '''Base class for encoding tokens as integers. Initializes its state with
    an `_index` object, that maps the space of tokens to integer indices.
    '''
    def __init__(self, vocabulary, vocabulary_max_size=None, **kwargs):
        trimmed = _trim_vocabulary(vocabulary, vocabulary_max_size)
        self._index = {token: i for (i, token) in enumerate(trimmed)}
        self._input_dim = len(self._index)

    def __call__(self, tokens):
        return [
            self._index[token] for token in tokens
            if token in self._index
        ]

    def transform(self, records):
        raise NotImplementedError()


class DenseEncoder(_BoWEncoder):
    '''Token encoder whose `transform` method returns a dense NumPy array.'''

    def __init__(self, vocabulary, vocabulary_max_size=None, **kwargs):
        super().__init__(vocabulary, vocabulary_max_size)

    def transform(self, records):
        '''Transforms a list of encoded records into a 2D NumPy tensor.'''
        shape = len(records), self._input_dim
        matrix = np.empty(shape, dtype=np.float32)
        for row, indices in enumerate(records):
            matrix[row, indices] = 1
        return matrix


class SparseEncoder(_BoWEncoder):
    '''Token encoder whose `transform` method returns a SciPy sparse array.'''

    def __init__(self, vocabulary, vocabulary_max_size=None, **kwargs):
        super().__init__(vocabulary, vocabulary_max_size)

    def transform(self, records):
        '''Transforms a list of encoded records into a 2D sparse tensor.'''
        shape = len(records), self._input_dim
        row_ind, col_ind = [], []
        for row, indices in enumerate(records):
            col_ind.extend(indices)
            row_ind.extend([row] * len(indices))

        return sparse.csr_matrix(
            ([1] * len(row_ind), (row_ind, col_ind)),
            shape=shape,
            dtype=np.float32)


class EmbeddingEncoder(object):
    '''Token encoder whose `transform` method returns NumPy array of
    integer indices compatible with TensorFlow Embedding layers.
    '''

    def __init__(self,
        vocabulary,
        input_length,
        vocabulary_max_size=None, **kwargs):
        trimmed = _trim_vocabulary(vocabulary, vocabulary_max_size)
        # uses index 0 for padding
        self._index = {token: i+1 for (i, token) in enumerate(trimmed)}
        self._input_dim = len(self._index)+1
        self._input_length = int(input_length)

    def __call__(self, tokens):
        return [
            self._index[token] for token in tokens
            if token in self._index
        ]

    def transform(self, records):
        '''Transforms a list of encoded records into a 2D NumPy tensor of
        integer indices with padding.'''
        shape = len(records), self._input_length
        # this is where 0-padding is enforceds
        matrix = np.zeros(shape, dtype=np.int32)
        for row, indices in enumerate(records):
            row_size = min(self._input_length, len(indices))
            matrix[row,0:row_size] = indices[:row_size]
        return matrix


class NumericEncoder(object):

    def __init__(self, dtype='int32', **kwargs):
        self._dtype = np.dtype(dtype)

    def __call__(self, value):
        return value

    def transform(self, values):
        return np.array(values, dtype=self._dtype)
