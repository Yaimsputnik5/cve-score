import numpy as np
from scipy import sparse


def _trim_vocabulary(vocabulary, vocabulary_max_size=None):
    '''Extracts a vocabulary constrained to a target size.

    Arguments:
        vocabulary: [dict] mapping tokens to frequencies.
        vocabulary_max_size: [int] target size of return value. If `None`
            the full vocabulary is used, and likewise if it exceeds the
            size of the input.

    Returns a _list_ of target size.
    '''
    size = vocabulary_max_size or len(vocabulary)
    if isinstance(vocabulary, dict):
        sorted_ = sorted(
            vocabulary.items(), key=lambda pair: pair[1], reverse=True)
        return [token for (token, _) in sorted_[:size]]
    raise ValueError('"vocabulary" must be a dict.')


class _BoWEncoder(object):
    def __init__(self, vocabulary, vocabulary_max_size=None, **kwargs):
        trimmed = _trim_vocabulary(vocabulary, vocabulary_max_size)
        self._index = {token: i for (i, token) in enumerate(trimmed)}
        self._input_dim = len(self._index)

    def __call__(self, tokens):
        return [
            self._index[token] for token in tokens
            if token in self._index
        ]


class DenseEncoder(_BoWEncoder):
    PROPERTIES = {
        'encoder': 'dense'
    }

    def __init__(self, vocabulary, vocabulary_max_size=None, **kwargs):
        super().__init__(vocabulary, vocabulary_max_size)
        self.PROPERTIES['input_dim'] = self._input_dim

    def transform(self, records):
        '''Transforms a list of encoded records into a 2D numpy tensor.'''
        shape = len(records), self._input_dim
        matrix = np.empty(shape, dtype=np.float32)
        for row, indices in enumerate(records):
            matrix[row, indices] = 1
        return matrix


class SparseEncoder(_BoWEncoder):
    PROPERTIES = {
        'encoder': 'sparse'
    }

    def __init__(self, vocabulary, vocabulary_max_size=None, **kwargs):
        super().__init__(vocabulary, vocabulary_max_size)
        self.PROPERTIES['input_dim'] = self._input_dim

    def transform(self, records):
        '''Transforms a list of encoded records into a 2D sparse tensor.'''
        shape = len(records), self._input_dim
        row_ind, col_ind = [], []
        for row, indices in enumerate(records):
            col_ind.extend(indices)
            row_ind.extend([row] * len(indices))

        return sparse.csr_matrix(
            ([1] * len(row_ind), (row_ind, col_ind)),
            shape=shape,
            dtype=np.float32)


class NumericEncoder(object):
    PROPERTIES = {
        'encoder': 'numeric',
    }

    def __init__(self, dtype='int32', **kwargs):
        self._dtype = np.dtype(dtype)
        self.PROPERTIES['dtype'] = dtype

    def __call__(self, value):
        return value

    def transform(self, values):
        return np.array(values, dtype=self._dtype)
